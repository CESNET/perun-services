#!/usr/bin/perl

use strict;
use warnings;
use perunServicesInit;
use perunServicesUtils;
use JSON::XS;
use Data::Dumper;

our $SERVICE_NAME = "generic_json_gen";
our $PROTOCOL_VERSION = "3.0.0";
my $SCRIPT_VERSION = "3.0.0";

# Get information about service and its attributes
perunServicesInit::init;
my $DIRECTORY = perunServicesInit::getDirectory;
my $data = perunServicesInit::getHashedDataWithGroups;

my $agent = perunServicesInit->getAgent;
my $attributesAgent = $agent->getAttributesAgent;
my $servicesAgent = $agent->getServicesAgent;
my $service = $servicesAgent->getServiceByName(name => $::SERVICE_NAME);
# Get all required attributes definitions for this service
my @requiredAttributesDefinitions = $attributesAgent->getRequiredAttributesDefinition(service => $service->getId);

# Constant attributes
our $A_R_UUID;					 *A_R_UUID =                   \'urn:perun:resource:attribute-def:core:uuid';
our $A_G_UUID;					 *A_G_UUID =                   \'urn:perun:group:attribute-def:core:uuid';
our $A_V_UUID;					 *A_V_UUID =                   \'urn:perun:vo:attribute-def:core:uuid';
our $A_U_UUID;					 *A_U_UUID =                   \'urn:perun:user:attribute-def:core:uuid';
our $A_F_UUID;					 *A_F_UUID =                   \'urn:perun:facility:attribute-def:core:uuid';

# Check attribute definitions, if all required attributes are present, group them by entity
my $requiredAttributes = {
	"facility"        => {},
	"vo"              => {},
	"group"           => {},
	"group_resource"  => {},
	"resource"        => {},
	"user"            => {},
	"user_facility"   => {},
	"member_resource" => {},
	"member_group"    => {},
};
for my $attribute (@requiredAttributesDefinitions) {
	my $namespace = $attribute->getNamespace();
	my @namespaceParts = split(":", $namespace);
	my $entity = $namespaceParts[2];
	my $urn = $namespace.":".$attribute->getFriendlyName;
	$requiredAttributes->{$entity}->{$urn} = undef;
}
# Check if const attributes are present
# if (!exists($requiredAttributes->{"facility"}->{$A_F_UUID})) {
# 	die("Attribute $A_F_UUID is required for this service");
# }
# if (!exists($requiredAttributes->{"vo"}->{$A_V_UUID})) {
# 	die("Attribute $A_V_UUID is required for this service");
# }
if (!exists($requiredAttributes->{"group"}->{$A_G_UUID})) {
	die("Attribute $A_G_UUID is required for this service");
}
if (!exists($requiredAttributes->{"resource"}->{$A_R_UUID})) {
	die("Attribute $A_R_UUID is required for this service");
}
if (!exists($requiredAttributes->{"user"}->{$A_U_UUID})) {
	die("Attribute $A_U_UUID is required for this service");
}

# Get constant information for facility
my $facility = perunServicesInit::getFacility;
my $facilityName = $facility->getName;
print("Generating JSON for facility ".$facilityName."\n");

my @destinations = $servicesAgent->getDestinations(service => $service->getId, facility => $facility->getId);
my @facilityDestinations;
for my $destination (@destinations) {
	push(@facilityDestinations, $destination->getDestination);
}

# List all attributes for facility
for my $urn (keys %{$requiredAttributes->{facility}}) {
	my $attr = $attributesAgent->getAttribute(facility => $facility->getId, attributeName => $urn);
	if (!defined($attr)) {
		die("Attribute $urn does not exist for facility '" . $facility->getName . !"'");
	}
	$requiredAttributes->{facility}->{$urn} = $attr->getValue;
}

# Init Structure
my $output = {
	"metadata"  => {
		"version"  => $SCRIPT_VERSION,
		"facility" => {
			"facility_name" => $facilityName,
			"destinations" => \@facilityDestinations,
			"attributes"   => $requiredAttributes->{facility},
		}
	},
	"users"     => {}, # Fill later
	"vos"       => {}, # Fill later
	"groups"    => {}, # Fill later
	"resources" => {} # Fill later
};


# Generate structure with required attributes
# For fast lookup of UUID <-> ID mapping
my $lookup = {
	"uuids" => {}, 		# UUID -> ID mapping
	"ids"   => { 		# ID -> UUID mapping
		"vo" 	=> {}, 	# VO ID -> UUID mapping
		"group" => {}, 	# Group ID -> UUID mapping
		"resource" => {}, # Resource ID -> UUID mapping
	},
};

# VOs
my $voAgent = $agent->getVosAgent;
for my $voId ($data->getVoIds()) {
	my $vo = $voAgent->getVoById(id => $voId);
	my $voUUID = $vo->getUuid;
	if (!defined($voUUID)) {
		$voUUID = $voId;
	}
	# Lookup update
	$lookup->{uuids}->{$voUUID} = $voId;
	$lookup->{ids}->{vo}->{$voId} = $voUUID;

	# Load VO attributes
	my %attributes;
	for my $attribute (keys %{$requiredAttributes->{vo}}) {
		my $attr = $attributesAgent->getAttribute(vo => $voId, attributeName => $attribute);
		my $urn = $attr->getNamespace.":".$attr->getFriendlyName;
		$attributes{$urn} = $attr->getValue;
	}

	my $voobj = {
		"attributes" => \%attributes,
	};
	$output->{vos}->{$voUUID} = $voobj;
}


# Groups
my $groupAgent = $agent->getGroupsAgent;
for my $gropuId ($data->getGroupIds()) {
	print("Generating JSON for group $gropuId\n");
	my $group = $groupAgent->getGroupById(id => $gropuId);
	my $groupUUID = $group->getUuid;
	if (!defined($groupUUID)) {
		$groupUUID = $gropuId;
	}

	# Lookup update
	$lookup->{uuids}->{$groupUUID} = $gropuId;
	$lookup->{ids}->{group}->{$gropuId} = $groupUUID;

	# Load Group attributes (undef if not present)
	my %attributes;
	for my $attribute (keys %{$requiredAttributes->{group}}) {
		my $attr = $attributesAgent->getAttribute(group => $gropuId, attributeName => $attribute);
		my $urn = $attr->getNamespace.":".$attr->getFriendlyName;
		$attributes{$urn} = $attr->getValue;
	}

	my $groupobj = {
		"voUuid"          => $lookup->{ids}->{vo}->{$group->getVoId},
		"attributes"      => \%attributes,
		"parent_group"    => undef
	};
	$output->{groups}->{$groupUUID} = $groupobj;
}
# Re-fill parent_group
for my $groupId ($data->getGroupIds()) {
	my $group = $groupAgent->getGroupById(id => $groupId);
	my $groupUUID = $group->getUuid;
	my $groupobj = $output->{groups}->{$groupUUID};
	my $parentGroupId = $group->getParentGroupId;
	if (!defined($parentGroupId)){
		next;
	}
	my $parentGroupUuid = $lookup->{ids}->{group}->{$parentGroupId};
	if (defined($parentGroupUuid)) {
		$groupobj->{"parent_group"} = $parentGroupUuid;
	}
	$output->{groups}->{$groupUUID} = $groupobj;
}

# Resources
my $resourceAgent = $agent->getResourcesAgent;
for my $resourceId ($data->getResourceIds()) {
	my $resource = $resourceAgent->getResourceById(id => $resourceId);
	my $resourceUUID = $resource->getUuid;
	if (!defined($resourceUUID)) {
		$resourceUUID = $resourceId;
	}

	# Lookup update
	$lookup->{"uuids"}->{$resourceUUID} = $resourceId;
	$lookup->{"ids"}->{"resource"}->{$resourceId} = $resourceUUID;

	# Resource attributes
	my %attributes;
	for my $attribute (keys %{$requiredAttributes->{resource}}) {
		my $attr = $attributesAgent->getAttribute(resource => $resourceId, attributeName => $attribute);
		my $urn = $attr->getNamespace.":".$attr->getFriendlyName;
		$attributes{$urn} = $attr->getValue;
	}

	my $resourceobj = {
		"voUuid"          => $lookup->{ids}->{vo}->{$resource->getVoId},
		"attributes"      => \%attributes,
		"assigned_groups" => {
			# Fill later
		},
	};
	$output->{resources}->{$resourceUUID} = $resourceobj;
}
my $json = JSON::XS->new->utf8->pretty->encode($output);
print($json);
die;

# Users
my $userAgent = $agent->getUsersAgent;
for my $userId ($data->getUserIds()) {
	my $user = $userAgent->getUserById(id => $userId);
	my $userUUID = $user->getUuid;
	if (!defined($userUUID)) {
		$userUUID = $userId;
	}

	# Lookup update
	$lookup->{uuids}->{$userUUID} = $userId;
	$lookup->{ids}->{user}->{$userId} = $userUUID;

	my $userobj = {
		"allowed_vos"    => {},
		"allowed_groups" => {},
		"allowed_resources" => {},
		"attributes"     => {}, # Fill with user attributes
	};
	$output->{users}->{$userUUID} = $userobj;
}

# Pretty print $output
$json = JSON::XS->new->utf8->pretty->encode($output);
print($json);

perunServicesInit::finalize;
