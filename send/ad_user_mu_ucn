#!/usr/bin/perl
use strict;
use warnings;
no if $] >= 5.017011, warnings => 'experimental::smartmatch';
use Net::LDAPS;
use Net::LDAP::Entry;
use Net::LDAP::Message;
use Net::LDAP::LDIF;
use DBI;

# Import shared AD library
use ADConnector;
use ScriptLock;

sub process_add;
sub process_update;
sub ping_password_setter;
sub update_group_members;
sub add_members_to_entry;
sub remove_members_from_entry;
sub update_group_membership;

# log counters
my $counter_add = 0;
my $counter_update = 0;
my $counter_fail = 0;
my $counter_group_updated = 0;
my $counter_group_updated_with_errors = 0;
my $counter_group_failed = 0;

# define service
my $service_name = "ad_user_mu_ucn";

# GEN folder location
my $facility_name = $ARGV[0];
chomp($facility_name);
my $service_files_base_dir="../gen/spool";
my $service_files_dir="$service_files_base_dir/$facility_name/$service_name";

# BASE DN
open my $file, '<', "$service_files_dir/baseDN";
my $base_dn = <$file>;
chomp($base_dn);
close $file;

# propagation destination
my $namespace = $ARGV[1];
chomp($namespace);

# create service lock
my $lock = ScriptLock->new($facility_name . "_" . $service_name . "_" . $namespace);
($lock->lock() == 1) or die "Unable to get lock, service propagation was already running.";

# init configuration
my @conf = init_config($namespace);
my @ldap_locations = resolve_domain_controlers($conf[0]);
my $ldap = ldap_connect_multiple_options(\@ldap_locations);
my $filter = '(&(objectClass=person)(cn=9*))'; # this will minimize loaded users but still can contain normal UČO users !

# connect
ldap_bind($ldap, $conf[1], $conf[2]);

# load all data
my @perun_entries = load_perun($service_files_dir . "/" . $service_name . ".ldif");
my @ad_entries = load_ad($ldap, $base_dn, $filter, ['cn','displayName','sn','givenName','mail','userAccountControl','samAccountName']);

my %ad_entries_map = ();

foreach my $ad_entry (@ad_entries) {

	my $login = $ad_entry->get_value('samAccountName');
	if ($login =~ /^9[0-9]{6}$/) {
		# We now always skip non-9UČO users !!
		$ad_entries_map{ $login } = $ad_entry;
	}

}

# process data
process_add();
process_update();
update_group_members();

# disconnect
ldap_unbind($ldap);

# log results
ldap_log($service_name, "Added: " . $counter_add . " entries.");
ldap_log($service_name, "Updated: " . $counter_update. " entries.");
ldap_log($service_name, "Failed: " . $counter_fail. " entries.");

# print results for TaskResults in GUI
print "Added: " . $counter_add . " entries.\n";
print "Updated: " . $counter_update. " entries.\n";
print "Failed: " . $counter_fail. " entries.\n";

if ($counter_group_updated) {
	ldap_log($service_name, "Members of the guest group were updated.");
	print "Members of the guest group were updated.\n";
} elsif ($counter_group_failed) {
	ldap_log($service_name, "Updating members of the guest group failed.");
	print "Updating members of the guest group failed.\n";
} elsif ($counter_group_updated_with_errors) {
	ldap_log($service_name, "Members of the guest group were updated with errors.");
	print "Members of the guest group were updated with errors.\n";
} else {
	ldap_log($service_name, "Members of the guest group were not changed.");
	print "Members of the guest group were not changed.\n";
}

$lock->unlock();

if ($counter_fail or $counter_group_failed or $counter_group_updated_with_errors) {
	die "Process ended up with errors.\nSee log at: ~/perun-engine/send/logs/$service_name.log";
}

# END of main script

###########################################
#
# Main processing functions
#
###########################################

#
# Add new user entries to AD
# We create only entries for normal UČO users
#
sub process_add() {

	foreach my $perun_entry (@perun_entries) {

		# We create only entries for normal UČO users
		my $login = $perun_entry->get_value('samAccountName');
		unless ($login =~ /^9[0-9]{6}$/) {
			# We now always skip non-9UČO users !!
			next;
		}

		unless (exists $ad_entries_map{$login}) {

			# Add new entry to AD
			my $response = $perun_entry->update($ldap);
			unless ($response->is_error()) {
				# SUCCESS
				ldap_log($service_name, "Added: " . $perun_entry->dn());
				$counter_add++;
				# tell IS to set Password to AD
				ping_password_setter($login);
			} else {
				# FAIL
				ldap_log($service_name, "NOT added: " . $perun_entry->dn() . " | " . $response->error());
				ldap_log($service_name, $perun_entry->ldif());
				$counter_fail++;
			}

		}

	}
}

#
# Update existing user entries in AD
#
sub process_update() {

	foreach my $perun_entry (@perun_entries) {

		if (exists $ad_entries_map{$perun_entry->get_value('samAccountName')}) {

			my $ad_entry = $ad_entries_map{$perun_entry->get_value('samAccountName')};

			# attrs without cn since it's part of DN to be updated
			my @attrs = ('displayName','sn','givenName','mail');

			# stored log messages to check if entry should be updated
			my @entry_changed = ();

			# check each attribute
			foreach my $attr (@attrs) {
				if (compare_entry($ad_entry , $perun_entry , $attr) == 1) {
					# store value for log
					my @ad_val = $ad_entry->get_value($attr);
					my @perun_val = $perun_entry->get_value($attr);
					push(@entry_changed, "$attr | " . join(", ",sort(@ad_val)) .  " => " . join(", ",sort(@perun_val)));
					# replace value
					$ad_entry->replace(
						$attr => \@perun_val
					);
				}
			}

			# check UAC
			my $ad_entry_uac = $ad_entry->get_value('userAccountControl');

			# if disabled -> enable it
			unless (is_uac_enabled($ad_entry_uac) == 1) {

				my $original_ad_entry_uac = $ad_entry_uac;
				my $new_ad_entry_uac = enable_uac($ad_entry_uac);
				push( @entry_changed, "userAccountControl | $original_ad_entry_uac => $new_ad_entry_uac" );
				$ad_entry->replace(
					'userAccountControl' => $new_ad_entry_uac
				);

			}

			if (@entry_changed) {
				# Update entry in AD
				my $response = $ad_entry->update($ldap);
				unless ($response->is_error()) {
					# SUCCESS
					foreach my $log_message (@entry_changed) {
						ldap_log($service_name, "Updated: " . $ad_entry->dn() . " | " . $log_message);
					}
					$counter_update++;
				} else {
					# FAIL
					ldap_log($service_name, "NOT updated: " . $ad_entry->dn() . " | " . $response->error());
					ldap_log($service_name, $ad_entry->ldif());
					$counter_fail++;
				}
			}

		}

	}
}

#
# Ping IS that it must set password for user to AD
#
sub ping_password_setter() {

	my $login = shift;

	my $username;
	my $password;
	my $db_name;
	my $table_name;

	my $configPath = "/etc/perun/services/ad_user_mu_ucn/DB";
	open FILE, $configPath or die "Could not open config file $configPath: $!";
	while(my $line = <FILE>) {
		if($line =~ /^username: .*/) {
			$username = ($line =~ m/^username: (.*)$/)[0];
		} elsif($line =~ /^password: .*/) {
			$password = ($line =~ m/^password: (.*)$/)[0];
		} elsif($line =~ /^tablename: .*/) {
			$table_name = ($line =~ m/^tablename: (.*)$/)[0];
		} elsif($line =~ /^dbname: .*/) {
			$db_name = ($line =~ m/^dbname: (.*)$/)[0];
		}
	}

	if(!defined($password) || !defined($username) || !defined($table_name) || !defined($db_name)) {
		print "Can't get config data from config file.\n";
		exit 14;
	}

	my $dbh = DBI->connect("dbi:Oracle:$db_name",$username, $password,{RaiseError=>1,AutoCommit=>0,LongReadLen=>65536, ora_charset => 'AL32UTF8'}) or die "Connect to database $db_name Error!\n";

	my $changeExists = $dbh->prepare(qq{select 1 from $table_name where uin=?});
	$changeExists->execute($login);

	unless($changeExists->fetch) {

		my $insert = $dbh->prepare(qq{INSERT INTO $table_name (uin, import_time) VALUES (?, sysdate)});
		$insert->execute($login);

	}

	commit $dbh;
	$dbh->disconnect();

}

sub update_group_members {
	my $filter_groups = '(objectClass=group)';
	my $group_dn = 'CN=HostPerun,OU=Types,OU=MU,DC=ucn,DC=muni,DC=cz';

	my @per_val = ();
	foreach my $perun_entry (@perun_entries) {
		push (@per_val, $perun_entry->dn());
	}

	# load members of a group from AD based on DN in Perun => Group must exists in AD
	my @ad_val = load_group_members($ldap, $group_dn, $filter_groups);

	if ($? != 0) {
		ldap_log($service_name, "Unable to load Perun group members from AD: " . $group_dn);
		$counter_group_failed++;
		return;
	}

	# sort to compare
	my @sorted_ad_val = sort(@ad_val);
	my @sorted_per_val = sort(@per_val);

	# compare using smart-match (perl 5.10.1+)
	unless(@sorted_ad_val ~~ @sorted_per_val) {

		my %ad_val_map = map { $_ => 1 } @sorted_ad_val;
		my %per_val_map = map { $_ => 1 } @sorted_per_val;

		# we must get reference to real group from AD in order to call "replace"
		my $response_ad = $ldap->search( base => $group_dn, filter => $filter_groups, scope => 'base' );
		unless ($response_ad->is_error()) {
			# SUCCESS
			my $ad_entry = $response_ad->entry(0);
			update_group_membership($ad_entry, \%ad_val_map, \%per_val_map);

		} else {
			# FAIL (to get group from AD)
			$counter_group_failed++;
			ldap_log($service_name, "Group members NOT updated: " . $group_dn . " | " . $response_ad->error());
		}
	}
}

sub add_members_to_entry {

	my $ad_entry = shift;
	my $to_be_added = shift;
	my $return_code = 0;

	# chunks of size less than 5000 have to be used, because LDAP cannot process more than 5000 operations at once.
	my @chunks_to_add = ();

	push @chunks_to_add, [ splice @$to_be_added, 0, 4999 ] while @$to_be_added;

	foreach (@chunks_to_add) {
		$ad_entry->add(
			'member' => $_
		);
		my $response = $ad_entry->update($ldap);
		if ($response) {
			unless ($response->is_error()) {
				ldap_log($service_name, "Group members added: " . $ad_entry->dn() . " | \n" . join(",\n", @$_));
			} else {
				ldap_log($service_name, "Group members NOT added: " . $ad_entry->dn() . " | " . $response->error() . " | \n" . join(",\n", @$_));
				$return_code = 1;
			}
		}
	}

	return $return_code;
}

sub remove_members_from_entry {

	my $ad_entry = shift;
	my $to_be_removed = shift;
	my $return_code = 0;

	# chunks of size less than 5000 have to be used, because LDAP cannot process more than 5000 operations at once.
	my @chunks_to_remove = ();

	push @chunks_to_remove, [ splice @$to_be_removed, 0, 4999 ] while @$to_be_removed;

	foreach (@chunks_to_remove) {
		$ad_entry->delete(
			'member' => $_
		);
		my $response = $ad_entry->update($ldap);
		if ($response) {
			unless ($response->is_error()) {
				ldap_log($service_name, "Group members removed: " . $ad_entry->dn() . " | \n" . join(",\n", @$_));
			} else {
				ldap_log($service_name, "Group members NOT removed: " . $ad_entry->dn() . " | " . $response->error() . " | \n" . join(",\n", @$_));
				$return_code = 1;
			}
		}
	}

	return $return_code;
}

sub update_group_membership {

	my $ad_entry = shift;
	my $ad_members_state = shift;
	my $perun_members_state = shift;

	my @to_be_added = ();
	my @to_be_removed = ();

	foreach (keys %{$perun_members_state}) {
		unless (defined $ad_members_state->{$_}) {
			push (@to_be_added, $_);
		}
	}

	foreach (keys %{$ad_members_state}) {
		unless (defined $perun_members_state->{$_}) {
			push (@to_be_removed, $_);
		}
	}

	if (@to_be_added or @to_be_removed) {
		@to_be_added = sort @to_be_added;
		@to_be_removed = sort @to_be_removed;

		my $response_add = add_members_to_entry($ad_entry, \@to_be_added);
		my $response_remove = remove_members_from_entry($ad_entry, \@to_be_removed);

		if ($response_add or $response_remove) {
			$counter_group_updated_with_errors++;
		} else {
			$counter_group_updated++;
		}
	}
}
